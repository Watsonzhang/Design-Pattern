### 第一章 Mysql架构与历史
    1.1 mysql 逻辑架构
    1.2 并发控制
    1.3 事务
        1.3.1 隔离级别
        1.3.2 死锁
        1.3.3 事务日志
            使用事务日志，存储引擎在修改表数据的时候只需要修改其内存拷贝，再把修改行为持久到硬盘上事务日志中，
            而不用每次都将修改数据本身持久化到磁盘。由于事务日志是采用追加的方式，因此写日志的操作时磁盘上一
            小块区域的顺序IO。事务日志持久后，内存中被修改的数据在后台中可以慢慢刷回到磁盘。也就是说修改数据需要
            写两次磁盘。
        1.3.4 mysql中事务    
            自动提交 autocommit
            如果不显示开启一个事务，则每个查询都被当做一个事务执行提交操作。
            set session transaction isolation level committed  
            在事务中混合使用存储引擎
            隐式和显示锁定
                Innodb会根据隔离级别在需要的收货自动加锁
                所有锁都是在同一时刻被释放
                select lock in share mode 共享锁定
                select for update
                mysql也支持lock tables 和unlock tables 但是是在服务层实现，与存储引擎无关
                但是不能代替事务处理 如果引用需要用到事务 还是应该选择事务型存储引擎
        1.4 多版本并发控制
            mysql大多数事务型存储引擎都不是简单的行级别锁 基于性能的考虑都是实现了多版本并发控制mvcc 
            可以认为mvcc是行级锁的变种 很多情况下避免了加锁
            mvcc的实现 是通过保存某个时间点的快照来实现的
             比如说可重复读这个隔离级别：
                不管该事务执行多久，事务内看到的数据都是一致的。
                也就是说根据事务开始的时间不同 每个事务对同一张表 ，同一时刻看到的数据可能是不一样的
            例如innodb的MVCC
             每行记录后面保存的两个隐藏的列来实现。
             一个列保存了行的创建时间
             一个时保存行的过期时间  
             优点：保存这两个额外的系统版本号 大读书读取操作都可以不用加锁
             缺点：每行记录都需要额外的存储空间 需要做更多的行检查工作
             注：mvcc只在repeatable read read committed 两个隔离级别下工作
        1.5 mysql的存储引擎     
            1.5.1 Innodb存储引擎
            用来处理大量的短期事务  
            1.5.2 Myisam存储引擎
             不支持事务和行级锁
             表锁问题 所有查询长期处于locked状态
            1.5.3 其他存储引擎
        1.6 mysql的时间线
        1.7 mysql的开发模式
        1.8 总结     
### 第三章 服务性能剖析

### 第四章 Schema与数据类型优化
    4.1 选择优化的数据类型
        更小的通常更好
        简单就好
        尽量避免null
        4.1.1 整数类型
            tinyint samllint mediumint int bigint
        4.1.2 实数类型
            Decimal
        4.1.3 字符串类型
            varchar 变长 需要1到2个字节额外存储字符串的长度 当update时变的比原来更长 则需要分裂页放进页里(会保留空格)
            char 定长 mysql总是根据定义的字符串分配足够的空间 会删除所有的末尾空格 char值根据需要填充
            Blob和Text类型 当Blox和text值太大时 InnoDB会使用专门的“外部存储区域来进行存储”
        4.1.4 日期和时间类型
            datetime 1001年到9999年精度为秒 与时区无关 8个字节
            timestamp 保存了从1970年1月1日午夜以来的秒数 4个字节 1970-2038 依赖时区
        4.1.5 位数据类型
        4.1.6 选择标识符
        4.1.7 特殊类型数据 
    4.2 mysql schema设计中的陷阱
        太多的列
        太多的关联
        全能的枚举
        变相的枚举
    4.3 范式和反范式
        4.3.1 范式的优点与缺点
        4.3.2 反范式的优点与缺点
        4.3.3混用范式化与反范式化
    4.4 缓存表和汇总表
        4.4.1 物化视图
        4.4.2 计数器表
    4.5 加快alter table的操作的速度
        通过都是创建新表 然后插入数据 然后重命名
        modify表转换成alter column
        例子：alter table sakila.film alter column rental_duration set default 5;
        这个语句只修改.frm结构 不涉及数据 所以操作非常快
        4.5.1 只修改.frm文件
        4.5.2 快速创建myisam索引
    4.6 总结
        尽量避免过度设计
        使用小而简单的合适数据类型
        尽量使用相同数据类型存储类似的值
        注意可变长字符串
        尽量使用整型定义标识列
        小心使用eum和set



### 第五章 创建高性能索引
                               
                                                    
        
           